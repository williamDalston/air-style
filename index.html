<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="AI-powered virtual hair styling with real-time AR preview">
    <meta name="theme-color" content="#9333ea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%239333ea' width='100' height='100'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>‚úÇ</text></svg>">
    <title>Virtual Hair Styler AI</title>
    
    <!-- Performance: Resource Hints for faster CDN loading -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://justadudewhohacks.github.io" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://unpkg.com">
    <link rel="dns-prefetch" href="https://justadudewhohacks.github.io">
    
    <!-- Performance: Load Tailwind early (critical for initial render) -->
    <!-- Note: Tailwind CDN is used for simplicity. For production, consider using PostCSS plugin -->
    <!-- Note: CDN is for development. For production, build Tailwind CSS separately -->
    <script>
        // Suppress Tailwind CDN warning in console
        const originalWarn = console.warn;
        console.warn = function(...args) {
            if (args[0] && args[0].includes && args[0].includes('cdn.tailwindcss.com')) {
                return; // Suppress Tailwind CDN warning
            }
            originalWarn.apply(console, args);
        };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Performance: Defer Font Awesome (non-critical for initial render) -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"></noscript>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background-color: #121212;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        #app-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        /* The video and canvas must overlap perfectly */
        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Matches video */
            transform: scaleX(-1);
        }
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .controls-panel {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.85) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 0.75rem 1.25rem max(0.75rem, env(safe-area-inset-bottom));
            border-top-left-radius: 28px;
            border-top-right-radius: 28px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 -8px 32px rgba(0,0,0,0.6), 0 -2px 8px rgba(196, 132, 252, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 40vh;
            overflow-y: auto;
            min-height: auto;
        }
        
        .controls-panel.minimized {
            padding: 0.5rem 1.25rem max(0.5rem, env(safe-area-inset-bottom));
            max-height: 60px;
            overflow: hidden;
        }
        
        .panel-minimize-btn {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            width: 40px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 0.7);
            z-index: 10;
        }
        
        .panel-minimize-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.25);
            color: rgba(255, 255, 255, 0.9);
        }
        
        .panel-minimize-btn i {
            transition: transform 0.3s ease;
            font-size: 0.7rem;
        }
        
        .panel-minimize-btn.minimized i {
            transform: rotate(180deg);
        }
        
        .color-section {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .color-section.collapsed {
            max-height: 0;
            margin-bottom: 0;
            opacity: 0;
        }
        
        .color-section.collapsed .color-presets-container {
            display: none;
        }
        
        .collapse-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .collapse-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }
        
        .collapse-btn i {
            transition: transform 0.3s ease;
        }
        
        .collapse-btn.collapsed i {
            transform: rotate(180deg);
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .section-title {
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 0.4rem;
            padding: 0 0.25rem;
        }
        
        .hair-option-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            opacity: 0.75;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 0.5rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .hair-option-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(196, 132, 252, 0.1), rgba(139, 92, 246, 0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .hair-option-btn:hover {
            opacity: 1;
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.06);
        }
        .hair-option-btn:hover::before {
            opacity: 1;
        }
        .hair-option-btn.active {
            border-color: #c084fc;
            background: rgba(196, 132, 252, 0.15);
            transform: scale(1.05) translateY(-2px);
            opacity: 1;
            box-shadow: 0 4px 16px rgba(196, 132, 252, 0.3), 0 0 0 1px rgba(196, 132, 252, 0.2);
        }
        .hair-option-btn.active::before {
            opacity: 1;
        }
        .hair-option-btn:active {
            transform: scale(0.98);
        }
        .hair-option-btn:focus-visible {
            outline: 2px solid #c084fc;
            outline-offset: 2px;
        }
        
        .hair-icon-container {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .hair-option-btn.active .hair-icon-container {
            background: linear-gradient(135deg, rgba(196, 132, 252, 0.2), rgba(139, 92, 246, 0.1));
            border-color: rgba(196, 132, 252, 0.4);
            box-shadow: 0 2px 8px rgba(196, 132, 252, 0.2), inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }
        
        .color-preset-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 2.5px solid rgba(255, 255, 255, 0.2);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }
        .color-preset-btn:hover {
            transform: scale(1.15);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 0 3px rgba(196, 132, 252, 0.2);
        }
        .color-preset-btn:active {
            transform: scale(1.05);
        }
        .color-preset-btn:focus-visible {
            outline: 2px solid #c084fc;
            outline-offset: 3px;
        }
        
        .color-picker-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .color-picker-trigger {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(196, 132, 252, 0.15);
            border: 1px solid rgba(196, 132, 252, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 0.75rem;
            font-weight: 600;
            color: #c084fc;
        }
        .color-picker-trigger:hover {
            background: rgba(196, 132, 252, 0.25);
            border-color: rgba(196, 132, 252, 0.5);
            transform: translateY(-1px);
        }
        .color-picker-trigger:active {
            transform: translateY(0);
        }
        .color-picker-preview {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #colorPicker {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }
        
        /* Loader Styles */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            transition: opacity 0.5s ease;
        }
        .loader-ring {
            display: inline-block;
            position: relative;
            width: 72px;
            height: 72px;
            margin-bottom: 1.5rem;
        }
        .loader-ring div {
            box-sizing: border-box;
            display: block;
            position: absolute;
            width: 58px;
            height: 58px;
            margin: 7px;
            border: 6px solid #c084fc;
            border-radius: 50%;
            animation: loader-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            border-color: #c084fc transparent transparent transparent;
        }
        .loader-ring div:nth-child(1) { animation-delay: -0.45s; }
        .loader-ring div:nth-child(2) { animation-delay: -0.3s; }
        .loader-ring div:nth-child(3) { animation-delay: -0.15s; }
        @keyframes loader-ring {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error/Retry State */
        .error-state {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-align: center;
        }
        .retry-btn {
            background: linear-gradient(135deg, #c084fc, #a855f7);
            color: white;
            padding: 0.75rem 2rem;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            border: none;
            box-shadow: 0 4px 12px rgba(196, 132, 252, 0.3);
        }
        .retry-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(196, 132, 252, 0.4);
        }
        .retry-btn:active {
            transform: translateY(0);
        }

        /* Hide scrollbar for horizontal lists */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Header improvements */
        .header-gradient {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 50%, transparent 100%);
        }
        
        .camera-btn {
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .camera-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }
        .camera-btn:active {
            transform: scale(0.95);
        }
        .camera-btn:focus-visible {
            outline: 2px solid #c084fc;
            outline-offset: 2px;
        }
        
        .logo-container {
            background: linear-gradient(135deg, #9333ea, #7c3aed);
            box-shadow: 0 4px 12px rgba(147, 51, 234, 0.3);
        }
        
        /* Smooth scrolling for horizontal lists */
        .scroll-container {
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Better touch targets for mobile */
        @media (max-width: 640px) {
            .hair-option-btn {
                min-width: 72px;
            }
            .hair-icon-container {
                width: 3.75rem;
                height: 3.75rem;
            }
            .color-preset-btn {
                width: 2.75rem;
                height: 2.75rem;
            }
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div id="loading-content" class="flex flex-col items-center">
            <div class="loader-ring"><div></div><div></div><div></div><div></div></div>
            <h2 class="text-xl font-bold tracking-wider text-white mb-1">INITIALIZING AI</h2>
            <p class="text-gray-400 text-xs mt-2 uppercase tracking-widest font-medium">Loading Face Models...</p>
        </div>
        
        <div id="error-content" class="error-state">
            <div class="w-16 h-16 rounded-full bg-red-500/20 flex items-center justify-center mb-4">
                <i class="fas fa-exclamation-triangle text-red-400 text-2xl"></i>
            </div>
            <h2 class="text-xl font-bold text-white mb-2">Connection Failed</h2>
            <p id="error-msg" class="text-gray-400 text-sm px-6 max-w-xs">Unable to load AI resources.</p>
            <button onclick="location.reload()" class="retry-btn mt-6">Retry</button>
        </div>

        <div id="loading-status" class="text-gray-500 text-xs mt-6 h-4 font-mono text-center px-4"></div>
    </div>

    <div id="app-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        
        <!-- UI Overlay -->
        <div class="ui-layer">
            <!-- Header -->
            <div class="p-5 pt-7 flex justify-between items-center header-gradient pointer-events-auto">
                <div class="text-white flex items-center gap-3">
                    <div class="logo-container w-10 h-10 rounded-xl flex items-center justify-center">
                        <i class="fas fa-cut text-white text-base"></i>
                    </div>
                    <div>
                        <h1 class="font-bold text-base leading-tight tracking-tight">HairStyler</h1>
                        <span class="text-[10px] text-gray-300 uppercase tracking-widest font-medium">AR Preview</span>
                    </div>
                </div>
                <button onclick="capturePhoto()" class="camera-btn group text-white w-11 h-11 rounded-full flex items-center justify-center" aria-label="Capture photo">
                    <i class="fas fa-camera text-base group-hover:scale-110 transition-transform"></i>
                </button>
            </div>

            <!-- Main Controls -->
            <div class="controls-panel" id="controlsPanel">
                <button onclick="toggleControlsPanel()" class="panel-minimize-btn" id="panelMinimizeBtn" aria-label="Minimize controls">
                    <i class="fas fa-chevron-up"></i>
                </button>
                <!-- Color Palette -->
                <div class="color-section flex flex-col collapsed" id="colorSection">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                            <span class="section-title">Hair Color</span>
                            <button onclick="toggleColorSection()" class="collapse-btn collapsed" id="collapseBtn" aria-label="Toggle color section">
                                <i class="fas fa-chevron-up text-xs"></i>
                            </button>
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" id="colorPicker" value="#4B2918">
                            <button onclick="document.getElementById('colorPicker').click()" class="color-picker-trigger" aria-label="Custom color picker">
                                <div class="color-picker-preview" id="colorPreview" style="background-color: #4B2918;"></div>
                                <i class="fas fa-palette text-xs"></i>
                                <span>Custom</span>
                            </button>
                        </div>
                    </div>
                    <div class="color-presets-container">
                        <div class="flex items-center gap-3 overflow-x-auto pb-1 no-scrollbar scroll-container" id="color-presets">
                            <!-- Generated by JS -->
                        </div>
                    </div>
                </div>

                <!-- Style Selector -->
                <div class="flex flex-col">
                    <span class="section-title mb-2">Style</span>
                    <div class="flex gap-3 overflow-x-auto pb-1 no-scrollbar scroll-container">
                        <button onclick="setHair('bob')" class="hair-option-btn active flex flex-col items-center min-w-[80px]" aria-label="Bob hairstyle">
                            <div class="hair-icon-container">üë©</div>
                            <span class="text-[11px] text-gray-300 font-semibold">Bob</span>
                        </button>
                        <button onclick="setHair('long')" class="hair-option-btn flex flex-col items-center min-w-[80px]" aria-label="Long hairstyle">
                            <div class="hair-icon-container">üë©‚Äçü¶∞</div>
                            <span class="text-[11px] text-gray-300 font-semibold">Long</span>
                        </button>
                        <button onclick="setHair('afro')" class="hair-option-btn flex flex-col items-center min-w-[80px]" aria-label="Afro hairstyle">
                            <div class="hair-icon-container">üë©‚Äçü¶±</div>
                            <span class="text-[11px] text-gray-300 font-semibold">Afro</span>
                        </button>
                        <button onclick="setHair('spiky')" class="hair-option-btn flex flex-col items-center min-w-[80px]" aria-label="Spiky hairstyle">
                            <div class="hair-icon-container">üíá</div>
                            <span class="text-[11px] text-gray-300 font-semibold">Spiky</span>
                        </button>
                        <button onclick="setHair('bangs')" class="hair-option-btn flex flex-col items-center min-w-[80px]" aria-label="Bangs hairstyle">
                            <div class="hair-icon-container">üë±‚Äç‚ôÄÔ∏è</div>
                            <span class="text-[11px] text-gray-300 font-semibold">Bangs</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden canvas for snapshots -->
    <canvas id="snapshotCanvas" style="display:none;"></canvas>

    <script>
        // --- Configuration & State ---
        const COLORS = [
            { hex: '#1a1a1a', name: 'Black' },
            { hex: '#E8CCA8', name: 'Blonde' },
            { hex: '#5D2916', name: 'Brown' },
            { hex: '#8B0000', name: 'Red' },
            { hex: '#FF69B4', name: 'Pink' },
            { hex: '#663399', name: 'Purple' },
            { hex: '#95a5a6', name: 'Grey' },
            { hex: '#1e3799', name: 'Blue' }
        ];

        // More organic, lifelike hair paths using Bezier curves for natural flow
        const HAIR_PATHS = {
            bob: function() {
                const p = new Path2D();
                // Organic bob shape following head contour
                p.moveTo(8, 52);
                p.bezierCurveTo(8, 15, 12, 8, 28, 8);
                p.bezierCurveTo(45, 8, 55, 12, 62, 15);
                p.bezierCurveTo(75, 12, 85, 10, 92, 15);
                p.bezierCurveTo(95, 22, 96, 48, 94, 52);
                p.bezierCurveTo(96, 65, 94, 78, 88, 85);
                p.bezierCurveTo(85, 92, 80, 94, 75, 92);
                p.bezierCurveTo(73, 88, 72, 65, 72, 58);
                p.bezierCurveTo(72, 42, 68, 38, 62, 38);
                p.bezierCurveTo(56, 38, 52, 42, 52, 48);
                p.bezierCurveTo(52, 58, 51, 88, 48, 92);
                p.bezierCurveTo(43, 94, 38, 92, 35, 85);
                p.bezierCurveTo(28, 78, 26, 65, 28, 52);
                p.bezierCurveTo(26, 48, 25, 22, 28, 15);
                p.bezierCurveTo(35, 10, 45, 12, 52, 15);
                p.closePath();
                return p;
            },
            long: function() {
                const p = new Path2D();
                // Flowing long hair with natural waves
                p.moveTo(12, 42);
                p.bezierCurveTo(12, 8, 18, 4, 28, 4);
                p.bezierCurveTo(38, 4, 45, 6, 50, 8);
                p.bezierCurveTo(55, 6, 62, 4, 72, 4);
                p.bezierCurveTo(82, 4, 88, 8, 88, 12);
                p.bezierCurveTo(90, 18, 91, 42, 91, 48);
                p.bezierCurveTo(92, 65, 93, 100, 92, 115);
                p.bezierCurveTo(92, 125, 90, 132, 85, 138);
                p.bezierCurveTo(80, 142, 75, 143, 70, 141);
                p.bezierCurveTo(68, 135, 67, 105, 67, 95);
                p.bezierCurveTo(67, 78, 66, 62, 65, 58);
                p.bezierCurveTo(65, 42, 60, 38, 55, 38);
                p.bezierCurveTo(50, 38, 48, 42, 47, 48);
                p.bezierCurveTo(46, 58, 45, 62, 45, 78);
                p.bezierCurveTo(45, 95, 44, 105, 42, 135);
                p.bezierCurveTo(40, 141, 35, 143, 30, 138);
                p.bezierCurveTo(25, 132, 23, 125, 23, 115);
                p.bezierCurveTo(22, 100, 23, 65, 24, 48);
                p.closePath();
                // Add some flowing strands on the sides
                const strand1 = new Path2D();
                strand1.moveTo(88, 55);
                strand1.bezierCurveTo(90, 75, 92, 95, 91, 110);
                strand1.bezierCurveTo(89, 118, 87, 122, 84, 120);
                strand1.bezierCurveTo(86, 115, 86, 75, 88, 55);
                p.addPath(strand1);
                
                const strand2 = new Path2D();
                strand2.moveTo(12, 55);
                strand2.bezierCurveTo(10, 75, 8, 95, 9, 110);
                strand2.bezierCurveTo(11, 118, 13, 122, 16, 120);
                strand2.bezierCurveTo(14, 115, 14, 75, 12, 55);
                p.addPath(strand2);
                return p;
            },
            afro: function() {
                const p = new Path2D();
                // Voluminous afro with natural curl pattern
                p.moveTo(12, 62);
                p.bezierCurveTo(-5, 45, 8, 18, 25, 8);
                p.bezierCurveTo(35, 2, 42, -2, 50, -3);
                p.bezierCurveTo(58, -2, 65, 2, 75, 8);
                p.bezierCurveTo(92, 18, 105, 45, 88, 62);
                p.bezierCurveTo(95, 75, 92, 85, 85, 88);
                p.bezierCurveTo(78, 92, 72, 90, 68, 85);
                p.bezierCurveTo(68, 78, 68, 62, 65, 60);
                p.bezierCurveTo(62, 58, 58, 60, 55, 62);
                p.bezierCurveTo(52, 60, 48, 58, 45, 60);
                p.bezierCurveTo(42, 62, 42, 78, 42, 85);
                p.bezierCurveTo(38, 90, 32, 92, 25, 88);
                p.bezierCurveTo(18, 85, 15, 75, 22, 62);
                p.closePath();
                // Add curl definition
                const curl1 = new Path2D();
                curl1.arc(35, 25, 12, 0, Math.PI * 2);
                p.addPath(curl1);
                const curl2 = new Path2D();
                curl2.arc(65, 25, 12, 0, Math.PI * 2);
                p.addPath(curl2);
                const curl3 = new Path2D();
                curl3.arc(50, 35, 10, 0, Math.PI * 2);
                p.addPath(curl3);
                return p;
            },
            spiky: function() {
                const p = new Path2D();
                // Dynamic spiky hair with natural variation
                p.moveTo(18, 52);
                p.bezierCurveTo(18, 45, 18, 38, 20, 32);
                // Left spikes
                p.lineTo(16, 28);
                p.bezierCurveTo(14, 22, 18, 18, 22, 20);
                p.lineTo(28, 18);
                p.bezierCurveTo(30, 12, 35, 10, 38, 14);
                p.lineTo(42, 12);
                // Center spikes
                p.bezierCurveTo(45, 8, 50, 6, 52, 10);
                p.bezierCurveTo(55, 8, 58, 6, 60, 10);
                p.lineTo(62, 12);
                // Right spikes
                p.bezierCurveTo(65, 10, 70, 12, 72, 14);
                p.lineTo(78, 18);
                p.bezierCurveTo(82, 18, 86, 22, 84, 28);
                p.lineTo(80, 32);
                p.bezierCurveTo(82, 38, 82, 45, 82, 52);
                p.bezierCurveTo(82, 58, 80, 62, 78, 64);
                p.bezierCurveTo(75, 66, 72, 65, 70, 62);
                p.bezierCurveTo(68, 58, 65, 55, 62, 52);
                p.bezierCurveTo(58, 55, 55, 58, 52, 58);
                p.bezierCurveTo(48, 58, 45, 55, 42, 52);
                p.bezierCurveTo(38, 55, 35, 58, 32, 62);
                p.bezierCurveTo(30, 65, 27, 66, 24, 64);
                p.bezierCurveTo(22, 62, 20, 58, 18, 52);
                p.closePath();
                return p;
            },
            bangs: function() {
                const p = new Path2D();
                // Natural bangs with forehead coverage
                p.moveTo(8, 52);
                p.bezierCurveTo(8, 8, 12, 4, 28, 6);
                p.bezierCurveTo(35, 5, 42, 8, 48, 10);
                p.bezierCurveTo(52, 8, 55, 6, 62, 6);
                p.bezierCurveTo(78, 4, 82, 8, 92, 52);
                p.bezierCurveTo(93, 58, 92, 95, 91, 100);
                p.bezierCurveTo(90, 108, 85, 110, 80, 108);
                p.bezierCurveTo(78, 102, 78, 60, 78, 55);
                p.bezierCurveTo(78, 42, 72, 38, 68, 38);
                p.bezierCurveTo(64, 38, 60, 42, 58, 48);
                p.bezierCurveTo(55, 42, 52, 38, 48, 38);
                p.bezierCurveTo(44, 38, 40, 42, 38, 48);
                p.bezierCurveTo(36, 42, 32, 38, 28, 38);
                p.bezierCurveTo(24, 38, 22, 42, 22, 55);
                p.bezierCurveTo(22, 60, 22, 102, 20, 108);
                p.bezierCurveTo(15, 110, 10, 108, 9, 100);
                p.bezierCurveTo(8, 95, 9, 58, 8, 52);
                p.closePath();
                // Forehead bangs section
                const bangs = new Path2D();
                bangs.moveTo(18, 42);
                bangs.bezierCurveTo(25, 50, 35, 52, 45, 50);
                bangs.bezierCurveTo(55, 52, 65, 50, 82, 42);
                bangs.bezierCurveTo(65, 38, 55, 35, 45, 35);
                bangs.bezierCurveTo(35, 35, 25, 38, 18, 42);
                bangs.closePath();
                p.addPath(bangs);
                return p;
            }
        };

        // scale: relative to face width
        // yOffset: relative to forehead center
        const HAIR_CONFIG = {
            bob: { scale: 2.8, yOffset: -0.8 },
            long: { scale: 2.9, yOffset: -0.8 },
            afro: { scale: 3.5, yOffset: -1.4 },
            spiky: { scale: 2.6, yOffset: -1.2 },
            bangs: { scale: 2.8, yOffset: -0.9 }
        };

        let state = {
            isModelLoaded: false,
            currentStyle: 'bob',
            currentColor: '#4B2918',
            stream: null,
            isVideoReady: false,
            lastDetection: null,
            smoothedLandmarks: null,
            frameCount: 0,
            detectionInterval: 3, // Detect every 3 frames (20fps instead of 60fps)
            lastDetectionTime: 0,
            smoothedData: null, // Store smoothed key points
            cachedGradients: {}, // Cache gradients per color/style combo
            cachedFaceWidth: null, // Cache face width calculation
            hasFace: false, // Track if face is currently detected
            performanceMetrics: {
                fps: 0,
                frameTimes: [],
                detectionTimes: [],
                lastFPSUpdate: 0
            },
            errorCount: 0,
            hairAdjustments: {
                scale: 1.0,
                xOffset: 0,
                yOffset: 0,
                rotation: 0
            },
            modelCache: null, // IndexedDB cache for models
            initStartTime: performance.now() // Track total initialization time
        };

        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        // Optimize canvas context for performance
        const ctx = canvas.getContext('2d', { 
            alpha: true,
            willReadFrequently: false, // Optimize for drawing, not reading
            desynchronized: true, // Allow async rendering
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high'
        });
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('loading-status');

        // --- Initialization ---

        async function init() {
            const initStart = performance.now();
            
            // Initialize UI elements in parallel (non-blocking)
            requestIdleCallback(() => {
                renderColorPresets();
                const colorPreview = document.getElementById('colorPreview');
                if (colorPreview) {
                    colorPreview.style.backgroundColor = state.currentColor;
                }
            }, { timeout: 100 });
            
            try {
                // Initialize model cache
                await initModelCache();
                
                // 1. Start Camera concurrently with scripts loading
                const cameraPromise = startCamera();
                
                // 2. Load Library via Dynamic Script Injection (Retry Logic included)
                statusText.innerText = "Loading AI Core...";
                const scriptPromise = loadFaceAPIScript();
                
                // Wait for script to load
                await scriptPromise;
                statusText.innerText = "AI Core loaded!";

                // 3. Load Models (with caching)
                statusText.innerText = "Loading Neural Networks...";
                await loadModels();

                // 4. Wait for camera if it's not ready yet
                await cameraPromise;
                
                // 5. Start Detection Loop
                state.isModelLoaded = true;
                const initTime = ((performance.now() - initStart) / 1000).toFixed(2);
                console.log(`Initialization completed in ${initTime}s`);
                
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
                
                detectFrame(); // Start the loop

            } catch (error) {
                console.error(error);
                document.getElementById('loading-content').style.display = 'none';
                document.getElementById('error-content').style.display = 'flex';
                document.getElementById('error-msg').innerText = error.message;
                statusText.innerText = "";
            }
        }
        
        // Initialize IndexedDB for model caching
        async function initModelCache() {
            return new Promise((resolve, reject) => {
                if (!('indexedDB' in window)) {
                    console.warn('IndexedDB not supported, model caching disabled');
                    resolve();
                    return;
                }
                
                const request = indexedDB.open('hairStylerCache', 1);
                
                request.onerror = () => {
                    console.warn('IndexedDB open failed, model caching disabled');
                    resolve(); // Don't fail initialization
                };
                
                request.onsuccess = () => {
                    state.modelCache = request.result;
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('models')) {
                        db.createObjectStore('models', { keyPath: 'url' });
                    }
                };
            });
        }
        
        // Cache model in IndexedDB
        async function cacheModel(url, modelData) {
            if (!state.modelCache) return;
            
            try {
                const transaction = state.modelCache.transaction(['models'], 'readwrite');
                const store = transaction.objectStore('models');
                await store.put({ url, data: modelData, timestamp: Date.now() });
            } catch (e) {
                console.warn('Failed to cache model:', e);
            }
        }
        
        // Get cached model from IndexedDB
        async function getCachedModel(url) {
            if (!state.modelCache) return null;
            
            try {
                const transaction = state.modelCache.transaction(['models'], 'readonly');
                const store = transaction.objectStore('models');
                const request = store.get(url);
                
                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        const result = request.result;
                        // Cache valid for 7 days
                        if (result && (Date.now() - result.timestamp) < 7 * 24 * 60 * 60 * 1000) {
                            resolve(result.data);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => resolve(null);
                });
            } catch (e) {
                return null;
            }
        }

        // Helper function to find the correct landmark net name
        function findLandmarkNet(api) {
            if (!api || !api.nets) return null;
            
            // Log all available nets for debugging (only once)
            if (!findLandmarkNet._loggedNets) {
                const allNets = Object.keys(api.nets);
                console.log('Available face-api.js nets:', allNets);
                findLandmarkNet._loggedNets = true;
            }
            
            // Try common names in order of likelihood
            // face-api.js v0.22.2 uses faceLandmark68TinyNet (singular Landmark, with Tiny)
            const nameVariations = [
                'faceLandmark68TinyNet',      // Most likely: singular, with Tiny
                'faceLandmarks68TinyNet',     // Plural version
                'faceLandmark68Net',          // Without Tiny
                'faceLandmarks68Net',         // Plural, without Tiny
                'faceLandmarks68',            // Shorter
                'FaceLandmark68TinyNet',      // Capitalized
                'FaceLandmarks68TinyNet',     // Capitalized plural
            ];
            
            for (const name of nameVariations) {
                const net = api.nets[name];
                if (net !== null && net !== undefined && typeof net === 'object') {
                    // Create alias for consistency with our code
                    if (!api.nets.faceLandmarks68TinyNet) {
                        api.nets.faceLandmarks68TinyNet = net;
                    }
                    console.log(`‚úì Using landmark net: ${name}`);
                    return net;
                }
            }
            
            // Last resort: search all nets for any with "landmark" and ("68" or "tiny")
            const allNets = Object.keys(api.nets);
            for (const netName of allNets) {
                const lowerName = netName.toLowerCase();
                if (lowerName.includes('landmark') && 
                    (lowerName.includes('68') || lowerName.includes('tiny'))) {
                    const net = api.nets[netName];
                    if (net !== null && net !== undefined) {
                        console.log(`‚úì Found landmark net by search: ${netName}`);
                        api.nets.faceLandmarks68TinyNet = net;
                        return net;
                    }
                }
            }
            
            console.error('Could not find landmark net. Available nets:', allNets);
            return null;
        }

        // Robust script loader with fallback
        async function loadFaceAPIScript() {
            // If already loaded from a previous attempt and fully initialized
            try {
                const api = window.faceapi;
                if (api && api.nets && 
                    typeof api.nets.tinyFaceDetector !== 'undefined' && 
                    findLandmarkNet(api)) {
                    console.log("FaceAPI already fully loaded");
                    return;
                }
            } catch (e) {
                // Continue to load
            }

            // Preload the primary CDN for faster loading
            const link = document.createElement('link');
            link.rel = 'preload';
            link.as = 'script';
            link.href = 'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js';
            document.head.appendChild(link);
            
            const urls = [
                'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js',
                'https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js'
            ];

            for (const url of urls) {
                try {
                    await new Promise((resolve, reject) => {
                        console.log(`Attempting to load ${url}`);
                        // Remove any existing face-api script to avoid conflicts
                        const existingScript = document.querySelector('script[src*="face-api"]');
                        if (existingScript) {
                            existingScript.remove();
                        }
                        
                        const script = document.createElement('script');
                        script.src = url;
                        script.crossOrigin = 'anonymous';
                        script.async = true;
                        script.onload = () => {
                            console.log(`Script loaded: ${url}`);
                            resolve();
                        };
                        script.onerror = () => {
                            console.error(`Failed to load script: ${url}`);
                            reject(new Error(`Failed to load script: ${url}`));
                        };
                        document.head.appendChild(script);
                    });
                    
                    // Polling: Wait until the global object AND specific nets are ready
                    // Give it a small delay first to let the script fully initialize
                    statusText.innerText = "Initializing AI library...";
                    // Initial delay to let face-api.js fully initialize its nets
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    await new Promise((resolve, reject) => {
                        let attempts = 0;
                        const maxAttempts = 200; // 20 seconds timeout
                        // Use requestAnimationFrame for smoother polling (less CPU intensive)
                        let rafId, timeoutId;
                        const checkReady = () => {
                            attempts++;
                            
                            // Update status less frequently to reduce DOM updates
                            if (attempts % 15 === 0) {
                                statusText.innerText = `Initializing AI library... (${Math.round(attempts * 0.1)}s)`;
                            }
                            
                            // More robust checking - try accessing the nets object
                            try {
                                const api = window.faceapi;
                                if (api) {
                                    // Check if faceapi object exists
                                    if (api.nets) {
                                        // Check if nets object exists and has the required properties
                                        // The nets might be objects with loadFromUri methods
                                        const detector = api.nets.tinyFaceDetector;
                                        const landmarks = findLandmarkNet(api);
                                        
                                        // Check if they exist and are not null/undefined
                                        // In face-api.js v0.22.2, nets are objects (not necessarily functions)
                                        // They just need to exist and have a loadFromUri method when needed
                                        if (detector !== null && detector !== undefined && 
                                            landmarks !== null && landmarks !== undefined) {
                                            // Additional check: see if they are valid objects
                                            // The loadFromUri might be available after the net object exists
                                            if ((typeof detector === 'object' && detector !== null) &&
                                                (typeof landmarks === 'object' && landmarks !== null)) {
                                                console.log(`‚úì FaceAPI nets ready after ${attempts} attempts`);
                                                statusText.innerText = "AI library ready!";
                                                if (rafId) cancelAnimationFrame(rafId);
                                                if (timeoutId) clearTimeout(timeoutId);
                                                resolve();
                                                return;
                                            }
                                        }
                                    }
                                    
                                    // Alternative check: verify the structure matches what we'll use
                                    if (api.TinyFaceDetectorOptions && typeof api.TinyFaceDetectorOptions === 'function') {
                                        // This is a good sign the library is ready
                                        // But we still need nets, so continue checking
                                    }
                                }
                            } catch (e) {
                                // Continue checking
                                if (attempts % 20 === 0) {
                                    console.log(`Still waiting for FaceAPI... (attempt ${attempts})`);
                                }
                            }

                            if (attempts >= maxAttempts) {
                                if (rafId) cancelAnimationFrame(rafId);
                                if (timeoutId) clearTimeout(timeoutId);
                                // Final check
                                try {
                                    const api = window.faceapi;
                                    if (api && api.nets) {
                                        const detector = api.nets.tinyFaceDetector;
                                        const landmarks = findLandmarkNet(api);
                                        if (detector && landmarks) {
                                            console.log("FaceAPI ready on final check");
                                            resolve();
                                        } else {
                                            // Log available nets to help debug
                                            const availableNets = api.nets ? Object.keys(api.nets) : [];
                                            console.error("FaceAPI nets missing:", {
                                                hasApi: !!api,
                                                hasNets: !!api.nets,
                                                hasDetector: !!detector,
                                                hasLandmarks: !!landmarks,
                                                netsKeys: availableNets
                                            });
                                            
                                            // Try to find ANY landmark net as last resort
                                            let foundNet = null;
                                            for (const netName of availableNets) {
                                                const lowerName = netName.toLowerCase();
                                                if ((lowerName.includes('landmark') && lowerName.includes('68')) ||
                                                    (lowerName.includes('landmark') && lowerName.includes('tiny'))) {
                                                    foundNet = api.nets[netName];
                                                    console.log(`Found potential landmark net: ${netName}`);
                                                    break;
                                                }
                                            }
                                            
                                            if (foundNet) {
                                                console.log("Using found landmark net as fallback");
                                                api.nets.faceLandmarks68TinyNet = foundNet;
                                                resolve();
                                            } else {
                                                reject(new Error(`Script loaded but landmark net not found. Available nets: ${availableNets.join(', ')}`));
                                            }
                                        }
                                    } else {
                                        reject(new Error("Script loaded but faceapi object not found"));
                                    }
                                } catch (e) {
                                    reject(new Error(`Script loaded but initialization failed: ${e.message}`));
                                }
                            }
                            
                            if (attempts < maxAttempts) {
                                rafId = requestAnimationFrame(checkReady);
                            }
                        };
                        
                        rafId = requestAnimationFrame(checkReady);
                        
                        // Fallback timeout for safety (in case RAF stops)
                        timeoutId = setTimeout(() => {
                            if (rafId) cancelAnimationFrame(rafId);
                            if (attempts < maxAttempts) {
                                // Force final check
                                attempts = maxAttempts;
                                checkReady();
                            }
                        }, maxAttempts * 100);
                    });
                    
                    console.log(`Successfully initialized face-api from ${url}`);
                    return; // Exit function on success
                } catch (e) {
                    console.warn(`Attempt failed for ${url}: ${e.message}`);
                    // Loop continues to next URL
                }
            }
            throw new Error("Failed to load face-api.js from all sources. Check network connection.");
        }

        async function startCamera() {
            statusText.innerText = "Accessing Camera...";
            try {
                // Optimize camera settings for performance
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640, max: 1280 }, 
                        height: { ideal: 480, max: 720 },
                        facingMode: "user",
                        frameRate: { ideal: 30, max: 30 } // Limit to 30fps for better performance
                    } 
                });
                video.srcObject = stream;
                state.stream = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        state.isVideoReady = true;
                        handleResize();
                        resolve();
                    };
                });
            } catch (err) {
                throw new Error("Camera access denied. Please allow camera permission.");
            }
        }

        async function loadModels() {
            const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
            const MODEL_NAMES = ['tiny_face_detector_model-weights_manifest.json', 'face_landmark_68_tiny_model-weights_manifest.json'];
            
            try {
                // Verification - simplified because loader guarantees structure now
                const api = window.faceapi;
                if (!api) throw new Error("FaceAPI global not found");
                
                // Safe access to models
                const detector = api.nets.tinyFaceDetector;
                const landmark = findLandmarkNet(api);

                // Double check to fail gracefully
                if (!detector) throw new Error("TinyFaceDetector not found in library");
                if (!landmark) {
                    const availableNets = Object.keys(api.nets || {});
                    throw new Error(`LandmarkNet not found in library. Available nets: ${availableNets.join(', ')}`);
                }

                // Try to load from cache first (IndexedDB caching is complex for face-api models,
                // so we'll optimize the loading process instead)
                statusText.innerText = "Loading models...";
                
                // Load models in parallel for faster initialization
                // Note: face-api.js handles its own caching via browser cache
                const detectorPromise = detector.loadFromUri(MODEL_URL);
                const landmarkPromise = landmark.loadFromUri(MODEL_URL);
                
                // Wait for both to complete
                await Promise.all([detectorPromise, landmarkPromise]);
                
                statusText.innerText = "Models ready!";
            } catch (e) {
                console.error("Model loading failed:", e);
                throw new Error(`Model Error: ${e.message}`);
            }
        }

        // --- Detection Loop ---

        // Adaptive quality system - adjusts detection frequency based on performance
        function updateAdaptiveQuality() {
            const metrics = state.performanceMetrics;
            if (metrics.frameTimes.length < 10) return;
            
            const avgFrameTime = metrics.frameTimes.reduce((a, b) => a + b, 0) / metrics.frameTimes.length;
            const avgDetectionTime = metrics.detectionTimes.length > 0 
                ? metrics.detectionTimes.reduce((a, b) => a + b, 0) / metrics.detectionTimes.length 
                : 0;
            
            // If performance is poor, reduce detection frequency
            if (avgFrameTime > 33) { // > 30ms per frame = < 30fps
                state.detectionInterval = Math.min(5, state.detectionInterval + 1);
            } else if (avgFrameTime < 20 && avgDetectionTime < 50) { // Good performance
                state.detectionInterval = Math.max(2, state.detectionInterval - 1);
            }
            
            // Keep only last 30 measurements
            if (metrics.frameTimes.length > 30) {
                metrics.frameTimes.shift();
            }
            if (metrics.detectionTimes.length > 30) {
                metrics.detectionTimes.shift();
            }
        }

        // Calculate FPS
        function updateFPS() {
            const now = performance.now();
            const metrics = state.performanceMetrics;
            
            if (metrics.lastFPSUpdate === 0) {
                metrics.lastFPSUpdate = now;
                return;
            }
            
            const delta = now - metrics.lastFPSUpdate;
            if (delta >= 1000) { // Update every second
                const frameCount = state.frameCount - (metrics.frameCount || 0);
                metrics.fps = Math.round((frameCount / delta) * 1000);
                metrics.frameCount = state.frameCount;
                metrics.lastFPSUpdate = now;
            }
        }

        async function detectFrame() {
            const frameStart = performance.now();
            // Use requestAnimationFrame for smooth, non-blocking UI
            requestAnimationFrame(detectFrame);

            if (!state.isModelLoaded || !state.isVideoReady || video.paused || video.ended) return;

            state.frameCount++;
            
            // Throttle detection: only detect every N frames
            const shouldDetect = state.frameCount % state.detectionInterval === 0;
            
            // Only clear canvas if we need to redraw
            let needsRedraw = true;
            
            if (shouldDetect) {
                try {
                    const detectStart = performance.now();
                    
                    // Detect Face with optimized settings
                    const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions({ 
                        inputSize: 224, // Optimized size for speed/accuracy balance
                        scoreThreshold: 0.5 
                    })).withFaceLandmarks(true);

                    const detectTime = performance.now() - detectStart;
                    state.performanceMetrics.detectionTimes.push(detectTime);
                    state.errorCount = 0; // Reset error count on success

                    if (detection) {
                        state.hasFace = true;
                        state.lastDetection = detection;
                        state.lastDetectionTime = performance.now();
                        
                        // Resize to match canvas
                        const dims = faceapi.matchDimensions(canvas, video, true);
                        const resizedResult = faceapi.resizeResults(detection, dims);
                        
                        // Smooth landmarks
                        smoothLandmarks(resizedResult.landmarks);
                    } else {
                        state.hasFace = false;
                        // Clear cached face width when face is lost
                        state.cachedFaceWidth = null;
                    }
                } catch (e) {
                    console.warn("Detection dropped frame", e);
                    state.hasFace = false;
                    state.errorCount++;
                    
                    // Auto-recovery: if too many errors, increase interval
                    if (state.errorCount > 5) {
                        state.detectionInterval = Math.min(6, state.detectionInterval + 1);
                        state.errorCount = 0;
                    }
                }
            }
            
            // Only draw if we have landmarks or need to clear
            if (state.smoothedLandmarks && state.hasFace) {
                // Clear only the area we're drawing to (optimization)
                if (needsRedraw) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                drawHair(state.smoothedLandmarks);
            } else if (!state.hasFace && state.smoothedLandmarks) {
                // Fade out when face is lost
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawHair(state.smoothedLandmarks, 0.3);
                // Clear smoothed data after fade
                if (state.frameCount % 30 === 0) {
                    state.smoothedData = null;
                    state.smoothedLandmarks = null;
                }
            } else {
                // No face, clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Performance tracking
            const frameTime = performance.now() - frameStart;
            state.performanceMetrics.frameTimes.push(frameTime);
            updateFPS();
            
            // Update adaptive quality every 60 frames
            if (state.frameCount % 60 === 0) {
                updateAdaptiveQuality();
            }
        }

        // Smooth landmarks to prevent jittery movement
        function smoothLandmarks(newLandmarks, smoothingFactor = 0.3) {
            const jaw = newLandmarks.getJawOutline();
            const leftEyeBrow = newLandmarks.getLeftEyeBrow();
            const rightEyeBrow = newLandmarks.getRightEyeBrow();
            
            // Adaptive smoothing: use less smoothing when face is moving fast
            let adaptiveSmoothing = smoothingFactor;
            if (state.smoothedData) {
                const lastCenterX = (state.smoothedData.leftEyeBrow[4].x + state.smoothedData.rightEyeBrow[0].x) / 2;
                const newCenterX = (leftEyeBrow[4].x + rightEyeBrow[0].x) / 2;
                const movement = Math.abs(newCenterX - lastCenterX);
                // Increase smoothing factor (less smoothing) for fast movement
                if (movement > 5) {
                    adaptiveSmoothing = Math.min(0.6, smoothingFactor * 1.5);
                }
            }
            
            if (!state.smoothedData) {
                // First detection - store as-is
                state.smoothedData = {
                    jaw: jaw.map(p => ({ x: p.x, y: p.y })),
                    leftEyeBrow: leftEyeBrow.map(p => ({ x: p.x, y: p.y })),
                    rightEyeBrow: rightEyeBrow.map(p => ({ x: p.x, y: p.y }))
                };
                state.smoothedLandmarks = newLandmarks;
                return;
            }

            // Interpolate between old and new positions for key points
            state.smoothedData = {
                jaw: jaw.map((newPos, i) => {
                    const oldPos = state.smoothedData.jaw[i];
                    return {
                        x: oldPos.x + (newPos.x - oldPos.x) * adaptiveSmoothing,
                        y: oldPos.y + (newPos.y - oldPos.y) * adaptiveSmoothing
                    };
                }),
                leftEyeBrow: leftEyeBrow.map((newPos, i) => {
                    const oldPos = state.smoothedData.leftEyeBrow[i];
                    return {
                        x: oldPos.x + (newPos.x - oldPos.x) * adaptiveSmoothing,
                        y: oldPos.y + (newPos.y - oldPos.y) * adaptiveSmoothing
                    };
                }),
                rightEyeBrow: rightEyeBrow.map((newPos, i) => {
                    const oldPos = state.smoothedData.rightEyeBrow[i];
                    return {
                        x: oldPos.x + (newPos.x - oldPos.x) * adaptiveSmoothing,
                        y: oldPos.y + (newPos.y - oldPos.y) * adaptiveSmoothing
                    };
                })
            };
            
            // Keep reference to latest landmarks for other methods
            state.smoothedLandmarks = newLandmarks;
        }

        // Cache gradient calculations
        function getCachedGradient(color, style) {
            const cacheKey = `${color}-${style}`;
            if (state.cachedGradients[cacheKey]) {
                return state.cachedGradients[cacheKey];
            }
            
            // Convert hex color to RGB for realistic shading
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Create more realistic gradient for hair depth with multiple layers
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            const isDark = brightness < 128;
            
            // More natural color variations based on hair color darkness
            const lightBoost = isDark ? 45 : 35;
            const darkBoost = isDark ? 50 : 35;
            
            const gradient = {
                main: ctx.createRadialGradient(-30, -30, 0, -30, -30, 80),
                highlight: ctx.createLinearGradient(-40, -50, 40, 30),
                midtone: ctx.createLinearGradient(-50, -50, 50, 50),
                colors: {
                    light: { 
                        r: Math.min(255, r + lightBoost), 
                        g: Math.min(255, g + lightBoost), 
                        b: Math.min(255, b + lightBoost) 
                    },
                    dark: { 
                        r: Math.max(0, r - darkBoost), 
                        g: Math.max(0, g - darkBoost), 
                        b: Math.max(0, b - darkBoost) 
                    },
                    mid: {
                        r: Math.min(255, r + 15),
                        g: Math.min(255, g + 15),
                        b: Math.min(255, b + 15)
                    },
                    base: { r, g, b }
                }
            };
            
            // Main gradient - radial for more natural lighting
            gradient.main.addColorStop(0, `rgb(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b})`);
            gradient.main.addColorStop(0.3, color);
            gradient.main.addColorStop(0.7, `rgb(${gradient.colors.mid.r}, ${gradient.colors.mid.g}, ${gradient.colors.mid.b})`);
            gradient.main.addColorStop(1, `rgb(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b})`);
            
            // Midtone gradient for depth
            gradient.midtone.addColorStop(0, `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, 0.6)`);
            gradient.midtone.addColorStop(0.5, color);
            gradient.midtone.addColorStop(1, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.4)`);
            
            // Highlight gradient - more subtle and realistic
            gradient.highlight.addColorStop(0, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.3)`);
            gradient.highlight.addColorStop(0.3, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.15)`);
            gradient.highlight.addColorStop(0.7, 'transparent');
            gradient.highlight.addColorStop(1, 'transparent');
            
            state.cachedGradients[cacheKey] = gradient;
            return gradient;
        }

        // Create hair texture pattern for more realism with strand-like effect
        function createHairTexture(ctx, colors) {
            // Create a larger pattern canvas for better texture detail
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 60;
            patternCanvas.height = 60;
            const patternCtx = patternCanvas.getContext('2d');
            
            // Create more realistic hair strand pattern with multiple layers
            const imageData = patternCtx.createImageData(60, 60);
            const data = imageData.data;
            
            // Seed random for consistent pattern (but still varied)
            const strandGroups = 6;
            const strandPositions = [];
            for (let i = 0; i < strandGroups; i++) {
                strandPositions.push({
                    x: (i * 10) + 5 + (Math.random() * 4 - 2),
                    width: 2 + Math.random() * 2,
                    variation: Math.random() * 0.3
                });
            }
            
            for (let y = 0; y < 60; y++) {
                for (let x = 0; x < 60; x++) {
                    const idx = (y * 60 + x) * 4;
                    
                    // Check if pixel is on a strand
                    let onStrand = false;
                    let strandVariation = 0;
                    
                    for (const strand of strandPositions) {
                        const dist = Math.abs(x - (strand.x + Math.sin(y * 0.15 + strand.variation) * 3));
                        if (dist < strand.width) {
                            onStrand = true;
                            strandVariation = (strand.width - dist) / strand.width;
                            break;
                        }
                    }
                    
                    // Base noise for all pixels
                    const baseNoise = (Math.random() - 0.5) * 15;
                    
                    // Strand enhancement
                    const strandBoost = onStrand ? (strandVariation * 12) : 0;
                    
                    // Vertical flow variation
                    const flowVariation = Math.sin(y * 0.12) * 3;
                    
                    // Combined variation
                    const variation = baseNoise + strandBoost + flowVariation;
                    
                    data[idx] = Math.max(0, Math.min(255, colors.base.r + variation));     // R
                    data[idx + 1] = Math.max(0, Math.min(255, colors.base.g + variation)); // G
                    data[idx + 2] = Math.max(0, Math.min(255, colors.base.b + variation)); // B
                    data[idx + 3] = 45; // More visible for better texture
                }
            }
            
            patternCtx.putImageData(imageData, 0, 0);
            return ctx.createPattern(patternCanvas, 'repeat');
        }
        
        // Create hair strand overlay for more realistic appearance
        function drawHairStrands(ctx, path, colors, count = 15) {
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw individual hair strands with natural variation
            for (let i = 0; i < count; i++) {
                const offset = (i - count / 2) * (60 / count) + (Math.random() * 8 - 4);
                const startX = -35 + offset;
                const startY = -30 + (Math.random() * 10 - 5);
                
                // Vary strand thickness and opacity for realism
                const thickness = 0.6 + Math.random() * 0.8;
                const opacity = 0.08 + Math.random() * 0.12;
                const colorVariation = (Math.random() - 0.5) * 20;
                
                ctx.strokeStyle = `rgba(${
                    Math.max(0, Math.min(255, colors.base.r + colorVariation))
                }, ${
                    Math.max(0, Math.min(255, colors.base.g + colorVariation))
                }, ${
                    Math.max(0, Math.min(255, colors.base.b + colorVariation))
                }, ${opacity})`;
                
                ctx.lineWidth = thickness;
                ctx.globalAlpha = 0.8 + Math.random() * 0.2;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                // Create natural flowing curve with multiple control points
                const midX1 = startX + (Math.random() * 15 - 7.5);
                const midY1 = startY + 15 + (Math.random() * 8 - 4);
                const midX2 = midX1 + (Math.random() * 15 - 7.5);
                const midY2 = midY1 + 15 + (Math.random() * 8 - 4);
                const endX = midX2 + (Math.random() * 10 - 5);
                const endY = midY2 + 15 + (Math.random() * 10 - 5);
                
                // Use bezier curves for smooth, natural hair flow
                ctx.bezierCurveTo(
                    midX1, midY1,
                    midX2, midY2,
                    endX, endY
                );
                
                ctx.stroke();
            }
            
            // Add some finer detail strands
            ctx.lineWidth = 0.4;
            for (let i = 0; i < count * 0.6; i++) {
                const offset = (i - count / 2) * (65 / count) + (Math.random() * 10 - 5);
                const startX = -38 + offset;
                const startY = -28 + (Math.random() * 12 - 6);
                
                ctx.strokeStyle = `rgba(${colors.base.r}, ${colors.base.g}, ${colors.base.b}, ${0.05 + Math.random() * 0.06})`;
                ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                const endX = startX + (Math.random() * 20 - 10);
                const endY = startY + 20 + (Math.random() * 15 - 7.5);
                ctx.quadraticCurveTo(
                    startX + (endX - startX) * 0.5 + (Math.random() * 6 - 3),
                    startY + (endY - startY) * 0.5,
                    endX, endY
                );
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawHair(landmarks, opacity = 1.0) {
            // Use smoothed data if available, otherwise use raw landmarks
            const jaw = state.smoothedData ? state.smoothedData.jaw : landmarks.getJawOutline();
            const leftEyeBrow = state.smoothedData ? state.smoothedData.leftEyeBrow : landmarks.getLeftEyeBrow();
            const rightEyeBrow = state.smoothedData ? state.smoothedData.rightEyeBrow : landmarks.getRightEyeBrow();
            
            // Get additional landmarks for better positioning
            let nose, leftEye, rightEye;
            try {
                nose = landmarks.getNose();
                leftEye = landmarks.getLeftEye();
                rightEye = landmarks.getRightEye();
            } catch (e) {
                // Fallback if methods not available
                nose = [];
                leftEye = [];
                rightEye = [];
            }

            // Cache face width calculation
            if (!state.cachedFaceWidth || state.frameCount % 10 === 0) {
                const dx = jaw[16].x - jaw[0].x;
                const dy = jaw[16].y - jaw[0].y;
                state.cachedFaceWidth = Math.sqrt(dx * dx + dy * dy);
            }
            const faceWidth = state.cachedFaceWidth;

            // Improved forehead center calculation using multiple reference points
            const eyebrowCenterX = (leftEyeBrow[4].x + rightEyeBrow[0].x) / 2;
            const eyebrowCenterY = (leftEyeBrow[4].y + rightEyeBrow[0].y) / 2;
            
            // Use nose tip as additional reference for better vertical positioning
            const noseY = nose.length > 0 ? nose[3].y : eyebrowCenterY;
            const noseTipY = nose.length > 6 ? nose[3].y : noseY;
            
            // Calculate natural hairline position based on facial proportions
            // Hairline is typically about 1/3 of face height above eyebrows
            const chinY = jaw.length > 8 ? jaw[8].y : (jaw.length > 7 ? jaw[7].y : jaw[jaw.length - 1].y);
            const faceHeightEstimate = Math.abs(chinY - eyebrowCenterY);
            const naturalHairlineOffset = faceHeightEstimate * 0.35;
            const foreheadY = Math.min(eyebrowCenterY - naturalHairlineOffset, noseTipY - faceWidth * 0.2);
            
            // Calculate head rotation from multiple points for better alignment
            const eyeCenterX = leftEye.length > 0 && rightEye.length > 0
                ? ((leftEye[0].x + leftEye[3].x) / 2 + (rightEye[0].x + rightEye[3].x) / 2) / 2
                : eyebrowCenterX;
            
            // Use temple points for better side alignment (if jaw points available)
            const leftTempleX = jaw[0].x - (jaw[0].x - eyebrowCenterX) * 0.3;
            const rightTempleX = jaw[16].x + (eyebrowCenterX - jaw[16].x) * 0.3;
            const adjustedCenterX = (leftTempleX + rightTempleX) / 2;
            
            const centerX = adjustedCenterX + (state.hairAdjustments.xOffset * faceWidth / 100);
            const centerY = foreheadY + (state.hairAdjustments.yOffset * faceWidth / 100);

            // Style Config with user adjustments
            const config = HAIR_CONFIG[state.currentStyle];
            const scaleFactor = (faceWidth / 100) * config.scale * state.hairAdjustments.scale;

            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Translate to forehead center
            ctx.translate(centerX, centerY);
            
            // Rotate to match head tilt (calculated from multiple reference points for accuracy)
            // Use eyebrow angle as primary reference
            const eyebrowAngle = Math.atan2(rightEyeBrow[4].y - leftEyeBrow[0].y, rightEyeBrow[4].x - leftEyeBrow[0].x);
            
            // Also use eye center angle for more accuracy
            let eyeAngle = eyebrowAngle;
            if (leftEye.length > 0 && rightEye.length > 0) {
                const leftEyeCenter = {
                    x: (leftEye[0].x + leftEye[3].x) / 2,
                    y: (leftEye[0].y + leftEye[3].y) / 2
                };
                const rightEyeCenter = {
                    x: (rightEye[0].x + rightEye[3].x) / 2,
                    y: (rightEye[0].y + rightEye[3].y) / 2
                };
                const calculatedEyeAngle = Math.atan2(rightEyeCenter.y - leftEyeCenter.y, rightEyeCenter.x - leftEyeCenter.x);
                // Average the angles for smoother result
                eyeAngle = (eyebrowAngle + calculatedEyeAngle) / 2;
            }
            
            // Use jaw line angle for additional reference
            const jawAngle = Math.atan2(jaw[16].y - jaw[0].y, jaw[16].x - jaw[0].x);
            
            // Weighted average: eyebrows and eyes are most reliable for hair positioning
            const baseAngle = (eyeAngle * 0.7) + (jawAngle * 0.3);
            const angle = baseAngle + (state.hairAdjustments.rotation * Math.PI / 180);
            ctx.rotate(angle);

            ctx.scale(scaleFactor, scaleFactor);
            
            // Center the SVG path (0-100 coords) and apply vertical offset
            ctx.translate(-50, config.yOffset * 50);

            // Get cached gradient
            const gradient = getCachedGradient(state.currentColor, state.currentStyle);
            
            // Calculate lighting based on face orientation (head tilt and rotation)
            // More sophisticated lighting that accounts for 3D head position
            const headTilt = Math.abs(angle) * 180 / Math.PI;
            const headRotation = Math.abs(baseAngle) * 180 / Math.PI;
            
            // Calculate lighting intensity based on head orientation
            // Light comes from top-front, so face forward = brightest
            const tiltFactor = Math.max(0.3, 1 - (headTilt / 90));
            const rotationFactor = Math.max(0.4, 1 - (headRotation / 120));
            
            // Combine factors with slight bias toward tilt
            const lightingIntensity = (tiltFactor * 0.6) + (rotationFactor * 0.4);
            
            // Also calculate highlight position based on head angle
            const highlightOffsetX = Math.sin(angle) * 15;
            const highlightOffsetY = Math.cos(angle) * 10;
            
            // Get the hair path (now a function)
            const hairPath = typeof HAIR_PATHS[state.currentStyle] === 'function' 
                ? HAIR_PATHS[state.currentStyle]() 
                : HAIR_PATHS[state.currentStyle];
            
            // Draw shadow first (behind hair) - more realistic shadow with soft edges
            ctx.save();
            ctx.translate(2, 5);
            ctx.shadowColor = `rgba(0,0,0,${0.9 * lightingIntensity})`;
            ctx.shadowBlur = 28;
            ctx.shadowOffsetY = 12;
            ctx.shadowOffsetX = 1;
            ctx.fillStyle = `rgba(0,0,0,${0.5 * lightingIntensity})`;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Base shadow layer for depth
            ctx.save();
            ctx.translate(1, 3);
            ctx.fillStyle = `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, ${0.6 * lightingIntensity})`;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Base midtone layer for depth and volume
            ctx.save();
            ctx.fillStyle = gradient.midtone;
            ctx.shadowColor = `rgba(0,0,0,${0.3 * lightingIntensity})`;
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 3;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Main hair fill with radial gradient for natural lighting
            ctx.save();
            ctx.fillStyle = gradient.main;
            ctx.shadowColor = `rgba(0,0,0,${0.3 * lightingIntensity})`;
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 4;
            ctx.fill(hairPath);
            ctx.restore();

            // Add detailed texture/noise pattern for strand realism
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.globalAlpha = 0.7;
            const texturePattern = createHairTexture(ctx, gradient.colors);
            ctx.fillStyle = texturePattern;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Add individual hair strands for more realism
            drawHairStrands(ctx, hairPath, gradient.colors, 15);
            
            // Add finer detail strands
            ctx.save();
            ctx.strokeStyle = `rgba(${gradient.colors.base.r}, ${gradient.colors.base.g}, ${gradient.colors.base.b}, 0.12)`;
            ctx.lineWidth = 0.8;
            ctx.lineCap = 'round';
            for (let i = 0; i < 20; i++) {
                ctx.globalAlpha = 0.05 + (Math.random() * 0.08);
                ctx.beginPath();
                const x1 = -35 + (Math.random() * 70);
                const y1 = -25 + (Math.random() * 50);
                const x2 = x1 + (Math.random() * 20 - 10);
                const y2 = y1 + 15 + (Math.random() * 20);
                ctx.moveTo(x1, y1);
                ctx.quadraticCurveTo((x1 + x2) / 2 + (Math.random() * 6 - 3), (y1 + y2) / 2, x2, y2);
                ctx.stroke();
            }
            ctx.restore();

            // Highlights for realistic shine - more natural placement
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = gradient.highlight;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Additional highlight for shine effect with natural falloff - dynamic based on head position
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.25 * lightingIntensity;
            const shineGradient = ctx.createLinearGradient(
                -45 + highlightOffsetX, -55 + highlightOffsetY, 
                45 + highlightOffsetX, 25 + highlightOffsetY
            );
            shineGradient.addColorStop(0, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.6)`);
            shineGradient.addColorStop(0.3, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.3)`);
            shineGradient.addColorStop(0.6, 'transparent');
            shineGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = shineGradient;
            ctx.fill(hairPath);
            ctx.restore();
            
            // Soft volumetric highlights - position based on head orientation
            ctx.save();
            ctx.globalCompositeOperation = 'soft-light';
            ctx.globalAlpha = 0.2 * lightingIntensity;
            const volumeGradient = ctx.createRadialGradient(
                -25 + highlightOffsetX, -35 + highlightOffsetY, 5, 
                -25 + highlightOffsetX, -35 + highlightOffsetY, 60
            );
            volumeGradient.addColorStop(0, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.4)`);
            volumeGradient.addColorStop(0.5, `rgba(${gradient.colors.light.r}, ${gradient.colors.light.g}, ${gradient.colors.light.b}, 0.1)`);
            volumeGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = volumeGradient;
            ctx.fill(hairPath);
            ctx.restore();

            // Natural edge definition with gradient - softer, more organic
            ctx.save();
            const edgeGradient = ctx.createLinearGradient(-55, -55, 55, 55);
            edgeGradient.addColorStop(0, `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, 0.35)`);
            edgeGradient.addColorStop(0.3, `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, 0.25)`);
            edgeGradient.addColorStop(0.5, `rgba(${gradient.colors.base.r}, ${gradient.colors.base.g}, ${gradient.colors.base.b}, 0.15)`);
            edgeGradient.addColorStop(0.7, `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, 0.25)`);
            edgeGradient.addColorStop(1, `rgba(${gradient.colors.dark.r}, ${gradient.colors.dark.g}, ${gradient.colors.dark.b}, 0.3)`);
            ctx.strokeStyle = edgeGradient;
            ctx.lineWidth = 1.8;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.shadowColor = `rgba(0,0,0,${0.4 * lightingIntensity})`;
            ctx.shadowBlur = 4;
            ctx.stroke(hairPath);
            ctx.restore();
            
            // Subtle inner edge for depth
            ctx.save();
            ctx.strokeStyle = `rgba(${gradient.colors.base.r}, ${gradient.colors.base.g}, ${gradient.colors.base.b}, 0.1)`;
            ctx.lineWidth = 1.2;
            ctx.globalCompositeOperation = 'multiply';
            ctx.stroke(hairPath);
            ctx.restore();

            ctx.restore();
        }

        // --- UI Logic ---

        function renderColorPresets() {
            const container = document.getElementById('color-presets');
            if (!container) return;
            
            // Use DocumentFragment for better performance (batch DOM updates)
            const fragment = document.createDocumentFragment();
            COLORS.forEach(color => {
                const btn = document.createElement('button');
                btn.className = "color-preset-btn flex-shrink-0";
                btn.style.backgroundColor = color.hex;
                btn.setAttribute('aria-label', `${color.name} hair color`);
                btn.onclick = () => setColor(color.hex);
                fragment.appendChild(btn);
            });
            container.appendChild(fragment);
        }

        window.setHair = (style) => {
            state.currentStyle = style;
            document.querySelectorAll('.hair-option-btn').forEach(btn => btn.classList.remove('active'));
            // Find the button that was clicked
            const buttons = document.querySelectorAll('.hair-option-btn');
            buttons.forEach(btn => {
                const onclickAttr = btn.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${style}'`)) {
                    btn.classList.add('active');
                }
            });
            // Clear gradient cache when style changes
            state.cachedGradients = {};
        }

        window.setColor = (color) => {
            state.currentColor = color;
            const colorPicker = document.getElementById('colorPicker');
            const colorPreview = document.getElementById('colorPreview');
            if (colorPicker) colorPicker.value = color;
            if (colorPreview) colorPreview.style.backgroundColor = color;
            // Clear gradient cache when color changes
            state.cachedGradients = {};
        }
        
        window.toggleColorSection = () => {
            const section = document.getElementById('colorSection');
            const btn = document.getElementById('collapseBtn');
            if (section && btn) {
                section.classList.toggle('collapsed');
                btn.classList.toggle('collapsed');
            }
        }
        
        window.toggleControlsPanel = () => {
            const panel = document.getElementById('controlsPanel');
            const btn = document.getElementById('panelMinimizeBtn');
            if (panel && btn) {
                panel.classList.toggle('minimized');
                btn.classList.toggle('minimized');
            }
        }

        // Hair adjustment functions (can be exposed via UI controls)
        window.adjustHair = {
            scale: (value) => {
                state.hairAdjustments.scale = Math.max(0.5, Math.min(2.0, value));
            },
            xOffset: (value) => {
                state.hairAdjustments.xOffset = Math.max(-20, Math.min(20, value));
            },
            yOffset: (value) => {
                state.hairAdjustments.yOffset = Math.max(-20, Math.min(20, value));
            },
            rotation: (value) => {
                state.hairAdjustments.rotation = Math.max(-15, Math.min(15, value));
            },
            reset: () => {
                state.hairAdjustments = { scale: 1.0, xOffset: 0, yOffset: 0, rotation: 0 };
            }
        };

        // Performance monitoring (can be toggled via console)
        window.getPerformanceStats = () => {
            const metrics = state.performanceMetrics;
            return {
                fps: metrics.fps,
                avgFrameTime: metrics.frameTimes.length > 0 
                    ? (metrics.frameTimes.reduce((a, b) => a + b, 0) / metrics.frameTimes.length).toFixed(2) + 'ms'
                    : 'N/A',
                avgDetectionTime: metrics.detectionTimes.length > 0
                    ? (metrics.detectionTimes.reduce((a, b) => a + b, 0) / metrics.detectionTimes.length).toFixed(2) + 'ms'
                    : 'N/A',
                detectionInterval: state.detectionInterval,
                hasFace: state.hasFace
            };
        };

        const colorPicker = document.getElementById('colorPicker');
        if (colorPicker) {
            colorPicker.addEventListener('input', (e) => {
                state.currentColor = e.target.value;
                const colorPreview = document.getElementById('colorPreview');
                if (colorPreview) colorPreview.style.backgroundColor = e.target.value;
            });
        }

        window.capturePhoto = () => {
            // Flash animation
            const flash = document.createElement('div');
            flash.className = 'fixed inset-0 bg-white z-[200] pointer-events-none transition-opacity duration-500';
            document.body.appendChild(flash);
            
            // Actual capture
            const snapCanvas = document.getElementById('snapshotCanvas');
            snapCanvas.width = video.videoWidth;
            snapCanvas.height = video.videoHeight;
            const snapCtx = snapCanvas.getContext('2d');

            // Flip because video is mirrored
            snapCtx.translate(snapCanvas.width, 0);
            snapCtx.scale(-1, 1);
            snapCtx.drawImage(video, 0, 0);
            
            // Draw existing overlay canvas on top
            // Note: Overlay canvas is already visually mirrored by CSS, but its internal data matches the mirrored video data logic
            snapCtx.drawImage(canvas, 0, 0, snapCanvas.width, snapCanvas.height);

            // Download
            const link = document.createElement('a');
            link.download = `hair-styler-${Date.now()}.png`;
            link.href = snapCanvas.toDataURL('image/png');
            link.click();

            // Remove flash
            requestAnimationFrame(() => {
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), 500);
            });
        }

        // Debounced resize handler
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (video && canvas) {
                    const displaySize = { width: video.clientWidth, height: video.clientHeight };
                    // Only resize if dimensions actually changed to avoid flicker
                    if (canvas.width !== displaySize.width || canvas.height !== displaySize.height) {
                        // Use device pixel ratio for crisp rendering on high-DPI displays
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = displaySize.width * dpr;
                        canvas.height = displaySize.height * dpr;
                        ctx.scale(dpr, dpr);
                        canvas.style.width = displaySize.width + 'px';
                        canvas.style.height = displaySize.height + 'px';
                        // Clear gradient cache on resize (canvas context may change)
                        state.cachedGradients = {};
                    }
                }
            }, 150); // Debounce resize events
        }

        window.addEventListener('resize', handleResize);
        
        // Use ResizeObserver for more efficient resize detection
        if (window.ResizeObserver && video) {
            const resizeObserver = new ResizeObserver(handleResize);
            resizeObserver.observe(video);
        }
        
        // Start App
        window.onload = init;

    </script>
</body>
</html>